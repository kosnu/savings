# Architecuture Overview

このドキュメントは、実行環境やデータベースの具体的な実装を明示せずに、
クリーンアーキテクチャ原則に基づくサーバーサイドアプリケーションの設計指針を示します。
開発者やアーキテクトがフレームワークやストレージの差異に影響されずに設計・実装できることを目的としています。

---

## 目的

- ビジネスロジック（ドメイン）を外部技術から分離して保守性を高める
- 入出力や永続化などの技術的関心事をアプリケーションの周辺に閉じ込める
- 実行環境（エッジ／サーバーレス／コンテナ等）や DB（RDB／NoSQL 等）を差し替えやすくする

## 概要（高レベル）

設計の中心はクリーンアーキテクチャで、依存の方向は内側（ビジネスルール）に向かいます。

```
interfaces ─▶ application ─▶ domain
                ▲
infrastructure ─┘
```

各層の責務は以下の通りです。

- Domain（ドメイン）: ビジネスエンティティ、値オブジェクト、ドメインルール。外部依存を持たない純粋な層。
- Application（アプリケーション）: ユースケース（UseCase）。ドメインを組み合わせて業務フローを実現する。外部実装には依存しない。
- Infrastructure（インフラ）: 永続化や外部システムとの連携の具象実装（DB クライアント、外部 API クライアント等）。ドメインの抽象（インターフェース）を実装する。
- Interfaces（インターフェース）: HTTP ハンドラ、ルーティング、入力検証、レスポンス整形などの外部向け入出力層。フレームワーク依存はここに閉じる。
- Shared（共通）: 全層で使われる共通型、エラークラス、ユーティリティ。

## 層の設計ポイント（契約）

簡潔な契約（インプット / アウトプット・エラー挙動）を各ユースケースに定義します。

- 入力: DTO（値のバリデーション済み）
- 出力: 明確な DTO / エンティティ／エラー型
- エラー: ドメインエラーとインフラエラーを区別し、上位層で取り扱いやすくする

これにより、UI 層やルーティング層はユースケースに対する依存のみとなり、実装の差し替えが容易になります。

## ディレクトリ（推奨）

```
src/
├── domain/
│   ├── {aggregate}/
│   │   ├── entities/
│   │   ├── valueObjects/
│   │   └── repository.ts  # Repository interface（抽象）
│   └── errors.ts
│
├── application/
│   ├── {aggregate}/
│   │   ├── dtos/
│   │   └── usecases/
│   └── services/          # 状態を持たないユースケース実装
│
├── infrastructure/
│   ├── db/                 # DB クライアントや接続管理（実装に依存）
│   └── {aggregate}RepositoryImpl.ts
│
├── interfaces/
│   ├── handlers/           # ハンドラ（ユースケース呼び出し）
│   ├── routes/             # ルーティング
│   └── server.ts           # アプリ初期化（DI 組み立て）
│
└── shared/
    ├── types.ts
    └── errors.ts
```

## 依存注入（DI）方針

- DI コンテナを必須とはしない。ルートやアプリ初期化時に明示的に実装を注入する方式を推奨する。
- 具象（Infrastructure）はドメインの抽象（Repository interface）に依存する。ユースケースは抽象のみを参照する。
- 環境変数や設定は集中管理し、テスト時に差し替えやすい形にする。

例（概念）:

- routes -> handler -> usecase -> repository(interface) -> repositoryImpl -> dbClient

## テスト戦略

- Domain 層: 純粋なユニットテスト（外部依存なし）
- Application 層: ユースケース単位でモック（Repository をモック）を使う
- Interfaces 層: E2E や統合テストで実行環境に近い形で検証するが、実環境の代わりにスタブやローカルエミュレータを使えるようにする

テスト時には、インフラ実装を差し替えるだけで同じユースケースが動くことを確認できる設計が重要です。

## 運用上の注意（環境非依存）

- 構成管理: 接続情報やシークレットは環境変数やシークレットストアで管理する。
- マイグレーション: スキーマやマイグレーションはインフラ層で扱うが、SQL 等の具体表現は運用ツールに任せること。
- モニタリング: ユースケースレベルでのメトリクス（成功/失敗/遅延）を計測するためのフックを用意する。

## ベストプラクティス（要点）

1. フレームワーク依存（ルーティングや HTTP 処理）は `interfaces/` に閉じる
2. DB・外部 API の具象実装は `infrastructure/` に閉じる
3. DTO と Entity を混在させない（変換を明示する）
4. ドメインは副作用を持たない関数と状態で表現する（テスト容易性向上）
5. ルート単位で明示的な DI を行い、テスト時に簡単に置き換えられるようにする

## まとめ

この文書は、実行環境やデータベースの具体名を明示せずに、クリーンアーキテクチャに従った安全で差し替え可能な設計を示しました。
実装時はこのガイドに従い、インフラや実行環境の差異は `infrastructure/` と `interfaces/` に閉じることで、将来的な移行コストを最小化できます。

---

必要であれば次のステップとして：

- 現在のリポジトリ構造に合わせた具体的なファイルテンプレートを追加します（例: RepositoryInterface の型定義、UseCase の雛形）。
- あるいは特定の実行環境向けに「適合レイヤー」（小さな導入ガイド）を別ファイルで用意します。
